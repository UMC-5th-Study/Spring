IPC 통신 - 프로세스끼리 통신(전기신호를 주고받는것)

IPC 통신 중에서도 소켓을 집중해서 보자
서로 다른 컴퓨터의 프로세스끼리 정보를 주고받기 위해서는
네트워크 상에서 컴퓨터를 식별하기 위해 IP주소, 
어느 프로세스로 보낼 지를 알기 위해서 포트번호가 필요하다 
백엔드에서는 tcp 전송을 사용한다

IPC(프로세스간 통신)을 위해서는
하드웨어를 무조건 거치고, 프로세스가 직접 하드웨어를
쓰지 않고 시스템 콜을 통해(os를 거쳐서 요청을 해서)
하드웨어를 직접 사용하지 않고 작업을 안전하게 수행한다

!여기서 프로세스가 서로 다른 컴퓨터에 잇을때 통신을 하면
네트워크 통신을 하는것

tcp, ip 등도 프로세스이고 시스템 콜이나 운영체제 자체 함수를
사용한다

네트워크에서 인터페이스 - 어려운 것을 대신 해주는 느낌
데이터 송신 과정에서 os를 사용을 할때 소켓이라는 
인터페이스를 쓰고, 소켓을 소켓 시스템 콜을 통해서 사용함

TCP 소켓과, UDP 소켓이 있고 TCP 소켓을 주로 사용한다
소켓에 있는 시스템 콜은 클라와 서버 쪽이 다르다

socket 프로토콜,     
socket(domain, type, protocol ); <- 도메인은 ipv4/ipv6 중에 선택, 타입은 stream/datagram 중에 선택, protocol은 숫자로 0 - 시스템이 6 - tcp, 17 - udp이다
socket(AF_INET, SOCK_STREAM, 0); <- ipv4 도메인, stream 소켓, 시스템이 프로토콜을 선택함
리눅스에서는 모든 것을 파일로 취급하고 소켓도 파일로 취급한다
write,read등 시스템 콜을 사용할때 파일 디스크립터(파일 식별)
을 이용해서 어떤 파일에 보내거나 받을지 정해준다. 
결국 socket() 프로토콜은 어떻게 사용할지 틀을 만들어주는 기능을 한다



bind 시스템 콜 
bind(sockfd, sockaddr, socklen_t)
bind 시스템 콜로 네트워크 통신을 위한 ip주소와 포트번호를 지정해줌
클라 서버는 N : 1 로 이루어져있음
서버의 ip와 포트가 바뀌면 n개의 클라이언트가 서버를 못찾음
서버는 ip와 포트를 고정해야되기에 bind로 고정


listen() 시스템 콜 - 중요!
listen(sockfd, backlog)
tcp의 3-way handshake를 통해서 신뢰성 있는 연결지향적인 통신을 함
클라이언트와 서버는 N:1상태, 서버는 클라이언트의 요청을 기다리는 상태
listen 큐에서는 클라이언트가 연결 요청을 보내고 <- syn 패킷을 클라이언트가 전송
연결 요청이 온 후 대기를 무한정 할수 없기에 연결 요청들을 받아둘 백로그 큐를 만든다
결론 - listen 시스템콜을 통해서 tcp를 대기 상태로 만든다

accept 시스템 콜 - 매우 중요
accept(sockfd, sockaddr , socklen_t);

tcp는 listen() 시스템 콜로 대기 상태가 되고 클라이언트들의 요청이 쌓이면 백로그 큐에 담아 둔다
accept는 백로그 큐에서 연결 요청을(syn)을 빼내서 연결을 수립힌다
tcp 는 accept로 연결 요청을 받고 
fork로 실제 통신에 대해서 응답을 하는 방법으로 분리되어있음
!accept 시스템 콜로 연결을 수립하고 accept 시스템 콜 다음에 3 way handshake의 나머지 2과정을 한다 - syn + ack와 ack를 한다

accept 시스템 콜 후에 멀티스레드를 통해서 3 way handshake의 나머지 2과정을 새로운 소켓을 생성해서 응답을 주게 된다
bind - listen 후에 부모 프로세스는 계속 accept로 연결 요청을 받고 자식 프로세스는 부모가 만든 소켓을 받아서 3way handshake의 나머지 2단계를 수행한다